\documentclass[12pt,letterpaper]{article}

\usepackage[titletoc]{appendix}
\usepackage[compatibility=false]{caption}

\usepackage{fullpage, listings, footnote, graphicx, multicol, enumitem, latexsym, placeins, csvsimple}
\usepackage{algorithm,algpseudocode}

\usepackage[backend=biber,style=numeric]{biblatex}

\usepackage{hyperref}
\usepackage{cleveref}

\DeclareLanguageMapping{american}{american-apa}
\addbibresource{Lab2.bib}

\setdescription{leftmargin=\parindent,labelindent=\parindent}
\pdfpxdimen=\dimexpr 1 in/72\relax
\lstdefinestyle{appendixPy}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  xleftmargin=\parindent,
  xrightmargin=\parindent,
  language=Python,
  showstringspaces=false,
  basicstyle=\small,
  numberstyle=\tiny,
  keywordstyle=\bfseries,
  commentstyle=\itshape,
  numbers = left,
  tabsize=4,
}
\lstdefinestyle{appendixJava}{%
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  xleftmargin=\parindent,
  xrightmargin=\parindent,
  language=Java,
  showstringspaces=false,
  basicstyle=\small,
  numberstyle=\tiny,
  keywordstyle=\bfseries,
  commentstyle=\itshape,
  numbers = left,
  tabsize=4,
}
\lstdefinestyle{appendixXML}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  xleftmargin=\parindent,
  xrightmargin=\parindent,
  language=XML,
  showstringspaces=false,
  basicstyle=\small,
  numberstyle=\tiny,
  keywordstyle=\bfseries,
  commentstyle=\itshape,
  numbers = left,
  tabsize=4,
}
\lstdefinestyle{insetJava}{%
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=tb,
  xleftmargin=\parindent,
  xrightmargin=\parindent,
  language=Java,
  showstringspaces=false,
  basicstyle=\small,
  numberstyle=\tiny,
  keywordstyle=\bfseries,
  commentstyle=\itshape,
  numbers = left,
  tabsize=4,
}

\author{Hawk Weisman\\Allegheny College Dept. of Computer Science}
\title{\texttt{traverse.py}: Automated Traversal of Filesystems for Data Collection \& Analysis}
\date{Monday, March 10th, 2014}

\begin{document}
	\maketitle
	\tableofcontents
	\pagebreak
	\section{Introduction}
		
		An understanding of filesystem characteristics is key to the successful design and implementation of operating systems. Knowledge of typical filesystem use patterns makes it possible to optimize filesystems to support those patterns. While these systems can be implemented based on projections and conjecture, information collected from real filesystems ``in the wild'' provide a much more accurate picture of filesystem use patterns. However, in order to draw meaningful conclusions from such empirically gathered data, it is necessary to collect samples from a large number of individual machines, across as wide a range of hardware and software environments and use cases as possible. Therefore, instruments for data collection must be as portable and versatile as possible.

		While previous research on filesystem characteristics exists \cite{agrawal2007five,evans2002study,leung2008measurement}, much of this research is localized to specific operating systems \cite{agrawal2007five}, specific locations or institutions \cite{agrawal2007five,evans2002study}, or to specific scales \cite{leung2008measurement}. In \citeyear{clark2004xen}, Clark et al. discussed the need for repeated research and reproducibility in experimental computer science, noting that researchers in computer science frequently report results for software they have implemented \cite{clark2004xen}. Research based on data-collection tools that are open-source, portable and multiplatform, and Internet-based make computer systems studies easily reproducible, improving the scientific rigor of the field. While the study described in this report is small in scope, it could easily grow to arbitrary scales, due primarily to the simplicity and the portability of the methods used for data collection.

	\section{Methods}

		\subsection{Traversal Tool Implementation}

			A tool was implemented to collect data on filesystem usage characteristics by automatically traversing filesystems using the recursive walk algorithm given in \cref{alg:recursivewalk}.
		
			\alglanguage{pseudocode}
			\begin{algorithm}
				\caption{Recursive walk algorithm for filesystem traversal and data collection.}
				\label{alg:recursivewalk}
				\begin{algorithmic}[1]
				\Procedure{traverse}{$directory$}
			   	\For{$item$ in $directory$}
			   		\State \Call{stat}{$item$}
			     	\If{\Call{type}{$item$} is directory}
			     	\State \Call{traverse}{$item$}
			     	\EndIf
			   	\EndFor
				\EndProcedure
				\end{algorithmic}
			\end{algorithm}

			Python was chosen for implementing the traversal tool for two primary reasons: one, cross-platform compatibility, allowing data to be collectied from a number of operating systems; and two, the availability of powerful statistical analysis and data visualization tools such as \texttt{numpy}, \texttt{scipy}, and \texttt{matplotlib} that allow data to be analyzed at collection time. While Python's interpreted nature may introduce additional delays to the already slow recursive walk algorithm which may take long periods of time to traverse large filesystem trees, performance was not considered as important a design consideration as portability and ease of programming, as the data collection program should not need to be run multiple times. Windows, Mac OS X, and POSIX-compatible Unix operating systems are the primary targets for this study, and the Python 3 interpreter is available on all of those environments. 

			Data was collected using the Python function \texttt{os.stat()}, which wraps the operating system's \texttt{stat} system call. All of the targeted operating systems this syscall, which, given a path, returns specific information on the inode at that path. The POSIX standard, implemented by most Unix operating systems, defines what information this syscall returns, and the Windows \texttt{stat} call conforms to this standard as well. A call to \texttt{stat} returns the following information:

			\begin{description}[leftmargin=3cm, style=sameline]
				\begin{multicols}{2}
					\item[\texttt{st\_mode}]{protection bits}
					\item[\texttt{st\_ino}]{inode number}
					\item[\texttt{st\_dev}]{device}
					\item[\texttt{st\_uid}]{user ID number of owner}
					\item[\texttt{st\_gid}]{group ID number of owner}
					\item[\texttt{st\_size}]{size of file (in bytes)}
				\end{multicols}
				\item[\texttt{st\_nlink}]{number of hard links to inode}
				\item[\texttt{st\_atime}]{timestamp of most recent access}
				\item[\texttt{st\_mtime}]{timestamp of most recent modification}
				\item[\texttt{st\_ctime}]{timestamp of most recent metadata change (Unix), or file creation \allowbreak(Windows)}
			\end{description}

			If information was collected using separate calls to functions such as \\\texttt{os.path.getsize()}, it would be necessary for the program to perform multiple system calls, and therefore, multiple disk access operations, increasing data collection time. 
			A complete listing of the source code for \texttt{traverse.py} is available in \cref{app:traverse}.

			Due to difficulties involving third-party packages required by \texttt{traverse.py}, a second tool, \texttt{traverselite.py}, was written to be used on machines where \texttt{traverse.py}'s dependencies were unavailable. While \texttt{traverselite.py} did not support the built-in graphing and statistics functions of the original program, it was easier to run, and could be run by users who did not have the privelages to install Python packages, such as the Allegheny College Computer Science Department network, and therefore allowed a much larger sample size. Source code for \texttt{traverselite.py} can be found in \cref{app:traverselite}.

		\subsection{Data Collection}

			Filesystem data was collected primarily from personal acquaintances of the author. Individuals interested in participating in the study were asked to fork a Git repository (\url{http://github.com/hawkw/traverse}) containing the Python script for data collection and a directory containing comma-separated values files output by that tool, to run the tool, and then to merge their fork with the master repository. Due to the size of some datasets, the output comma-separated values files were compressed using the Python standard library's built-in bzip2 compression.

			The use of a Git repository for distributing the experimental scripts and collecting data made conducting the study very easy, but also limited the study participants to individuals familiar with the use of version-control systems --- in this case, primarily Allegheny College students studying Computer Science. This may have biased the results collected in favour of use patterns common among Computer Science students that may not be as frequent among computer users in general. However, the process of interacting with a Git repository could be automated 

			The data-collection tool also recorded the time at which it was run, the root directory for traversal, the length of time taken by the traversal,  and the self-reported name of the operating system in a separate comma-separated values file in the data directory. This information is presented in \cref{app:data}.

		\subsection{Data Analysis \& Presentation}

			Data was analyzed using the IPython interactive computing environment \cite{ipython}. The \texttt{pandas} and \texttt{matplotlib} libraries \cite{pandas,matplotlib} were used for statistical analysis and visualization, respectively. Comma-separated values containing collected data were accessed from the Git repository using the metadata CSV file, with a known static URL, to retrieve the URLs of other data files. After retrieval, the data files were parsed into Pandas \texttt{DataFrame}s for analysis and graphing. A static copy of the IPython notebook used for data analysis may be viewed at \allowbreak\url{http://nbviewer.ipython.org/gist/hawkw/8906418}.

			Logarithmic histograms were produced for file size and link count, showing the distribution across all operating systems (\cref{fig:size_hist,fig:nlink_hist}) and for individual operating systems (\cref{fig:size_mac-hist,fig:size_ubuntu-hist,fig:nlink_mac-hist,fig:nlink_ubuntu-hist}). Items of size zero (directories) were excluded from plots of file size distribution for two reasons: one, that they are not technically files, and two, that they would bias histograms to the extent that the distribution pattern would be difficult to discern.

			Histograms were also prepared for measurements of file path depth, which was measured by counting the number of path separator characters\footnote{``\texttt{/}'' on Mac OS X and Ubuntu} in the path to each object found, with \cref{fig:depth} showing depth for the entire dataset, and \cref{fig:mac-depth,fig:ubuntu-depth}  showing depth for Mac OS X and Ubuntu. Three pairwise correlation plots were drawn: one of the entire dataset (\cref{fig:corrplot}), and one for each of the operating systems from which data was collected (\cref{fig:corrplot-mac,fig:corrplot-ubuntu}).

	\section{Results}

		Data was collected on a total of 1,232,894 filesystem objects. 956,880 of these were recorded from computers running Mac OS X, and 276,014 were recorded from machines running Ubuntu Linux.

		\Cref{table:size} shows the mean, minimum, and maximum file size recorded across multiple operating systems. For all operating systems, the smallest items encountered were zero bytes. These items are assumed to be directories.in size. A maximum file size of 1.76639 GB was observed on Mac OS X, and 11.7309 GB on Unbuntu.  The mean observed file size was 273.877 kB on Mac OS X, 469.0964 kB on Ubuntu, and 317.5818 kB across all observed computers. A standard deviation of 4.500786 MB was observed on Mac OS X, 28.4256 MB on Ubuntu, and 14.0222 MB across all operating systems.

		\Cref{fig:size_hist,fig:size_mac-hist,fig:size_ubuntu-hist} show the distribution of file sizes observed, plotted on a logarithmic axis. A majority of filesystem items observed fell into the smallest bin, even with 0-byte items (directories) excluded.

		\begin{table}[h]
		\centering
		\caption{Size of filesystem items}
		\label{table:size}
			\begin{tabular}{l r r r r}
			Operating System & mean  & standard dev & minimum & maximum \\
			\hline
			Mac OS X & 273.877 kB & 4.500786 MB & 0 B & 1.76639 GB \\
			Ubuntu & 469.0964 kB & 28.4256 MB & 0 B & 11.7309 GB \\
			Total  & 317.5818 kB & 14.0222 MB & 0 B & 11.7309 GB \\
			\end{tabular}
		\end{table}

		\begin{figure}[H]
			\centerline{\includegraphics[width=0.9\textwidth]{figures/size_hist.pdf}}
			\caption{Logarithmic histogram of file size distribution.}
			\label{fig:size_hist}
		\end{figure}

		\begin{figure}[H]
			\centerline{\includegraphics[width=0.9\textwidth]{figures/size_mac-hist.pdf}}
			\caption{Logarithmic histogram of file size distribution on Mac OS X.}
			\label{fig:size_mac-hist}
		\end{figure}

		\begin{figure}[H]
			\centerline{\includegraphics[width=0.9\textwidth]{figures/size_ubuntu-hist.pdf}}
			\caption{Logarithmic histogram of file size distribution on Ubuntu.}
			\label{fig:size_ubuntu-hist}
		\end{figure}

		\Cref{table:nlink} shows the mean, standard deviation, and minimum and maximum link counts observed on Mac OS X, Ubuntu, and across both operating systems. The mean number of links on Ubuntu was 1.429467, while the mean number of links on Mac OS X was 2.152924, implying that the average filesystem object on Mac OS X tends to have slightly more links than on Ubuntu. However, the standard deviation in link count observed Mac OS X, 35.360418 links, is over a power of ten greater than the standard deviation observed on Ubuntu, 3.559488 links. Furthermore, there was a significant difference between the maximum number of links observed on Mac OS X and Ubuntu. On OS X, the highest observed link count was 26,760, while the most linked object on Ubuntu had only 474.

		\begin{table}[h]
		\centering
		\caption{Link density of filesystem items}
		\label{table:nlink}
			\begin{tabular}{l r r r r}
			Operating System & mean  & standard dev & minimum & maximum \\
			\hline
			Mac OS X & 2.152924 links & 35.360418 links & 1 link & 26,760 links \\
			Ubuntu &  1.429467 links & 3.559488 links & 1 link & 474 links \\
			Total & 1.990960 links & 31.198756 links & 1 link & 26,760 links \\
			\end{tabular}
		\end{table}

		\Cref{fig:nlink_mac-hist,fig:nlink_ubuntu-hist} show logarithmic histograms for link count density on Mac OS X and Ubuntu, while \cref{fig:nlink_hist} shows a histogram for both operating systems. \Cref{fig:nlink_mac-hist,fig:nlink_ubuntu-hist} show that while the distributions were relatively similar, much higher link counts were observed on Ubuntu than on Mac OS X.

		\begin{figure}[H]
			\centerline{\includegraphics[width=0.9\textwidth]{figures/nlink_hist.pdf}}
			\caption{Logarithmic histogram of link count distribution.}
			\label{fig:nlink_hist}
		\end{figure}

		\begin{figure}[H]
			\centerline{\includegraphics[width=0.9\textwidth]{figures/nlink_mac-hist.pdf}}
			\caption{Logarithmic histograms of link count distribution on Mac OS X.}
			\label{fig:nlink_mac-hist}
		\end{figure}

		\begin{figure}[H]
			\centerline{\includegraphics[width=0.9\textwidth]{figures/nlink_ubuntu-hist.pdf}}
			\caption{Logarithmic histograms of link count distribution on Ubuntu.}
			\label{fig:nlink_ubuntu-hist}
		\end{figure}


		\begin{table}[h]
		\centering
		\caption{Depth of filesystem items}
		\label{table:depth}
			\begin{tabular}{l r r r r}
			Operating System & mean  & standard dev & minimum & maximum \\
			\hline
			Mac OS X & 11.92237 & 3.304652 & 3  & 26 \\
			Ubuntu &  10.18107 & 3.283197 & 3 & 21 \\
			Total & 11.53254 & 3.378747 & 3 & 26 \\
			\end{tabular}
		\end{table}

			\Cref{table:depth} shows the mean, standard deviation, and minimum and maximum link depths observed on Mac OS X, Ubuntu, and across both operating systems. The mean depth on Ubuntu was 10.18107 directories deep, while the mean depth observed on Mac OS X was 11.92237 directories deep. However, the difference between these two mean depths is within the standard deviation, implying that there is probably not a difference in depth between these operating systems.

		\begin{figure}[H]
			\centerline{\includegraphics[width=0.9\textwidth]{figures/depth_hist.pdf}}
			\caption{Histogram of file path depth.}
			\label{fig:depth}
		\end{figure}

		\begin{figure}[H]
			\centerline{\includegraphics[width=0.9\textwidth]{figures/depth_mac-hist.pdf}}
			\caption{Histogram of file path depth on Mac OS X.}
			\label{fig:mac-depth}
		\end{figure}

				\begin{figure}[H]
			\centerline{\includegraphics[width=0.9\textwidth]{figures/depth_ubuntu-hist.pdf}}
			\caption{Histogram of file path depth on Ubuntu.}
			\label{fig:ubuntu-depth}
		\end{figure}


		\Cref{fig:corrplot,fig:corrplot-mac,fig:corrplot-ubuntu} show pairwise correlation matricies for each variable in the dataset, with \cref{fig:corrplot} showing the entire dataset, \cref{fig:corrplot-mac} showing only data collected from computers running Mac OS X, and \cref{fig:corrplot-ubuntu} showing only data collected from computers running Ubuntu.

		\begin{figure}[H]
			\centerline{\includegraphics[width=0.9\textwidth]{figures/corrplot-master.pdf}}
			\caption{Correlation matrix (OS X and Ubuntu).}
			\label{fig:corrplot}
		\end{figure}

		\Cref{fig:corrplot} shows a strong correlation ($p = 0.98$) between user ID and group ID, relatively strong correlations between the time of last modification and last status change ($p  = 0.48$) and between inode number and device number ($p = 0.34$), and very weak correlations between device number and user ID ($p = -0.85$) and device number and group ID ($ p = -0.93$).

		\begin{figure}[H]
			\centerline{\includegraphics[width=0.9\textwidth]{figures/corrplot-mac.pdf}}
			\caption{Correlation matrix (OS X).}
			\label{fig:corrplot-mac}
		\end{figure}

		\Cref{fig:corrplot-mac} shows strong correlations between time modified and time created ($p = 0.63$), and between inode number and device number ($p = 0.62$),  weak correlations between device number time of last status change ($p = -0.51$) and device number and time of last modification ($-0.35$), and a relatively weak correlation between user ID and group ID ($p = -0.2$) on systems running Mac OS X.

		\begin{figure}[H]
			\centerline{\includegraphics[width=0.9\textwidth]{figures/corrplot-ubuntu.pdf}}
			\caption{Correlation matrix (Ubuntu).}
			\label{fig:corrplot-ubuntu}
		\end{figure}

		\Cref{fig:corrplot-ubuntu} shows strong correlations between user ID and group ID ($p = 0.99$), between inode number and group ID ($p = 0.93$) and between inode number and user ID ($p = 0.92$), and relatively weak correlations between inode number and device number ($p = -0.41$) on systems running Ubuntu.

		\pagebreak
	\section{Analysis \& Discussion}

		While both Mac OS X and Ubuntu are Unix-based, POSIX-compativle operating systems, this study identified several interesting differences between computers running these two operating systems:
		\begin{enumerate}
			\item{A much higher maximum file size and a slightly higher mean file size were observed on Ubuntu than on Mac OS X (\cref{table:size}).}
			\item{A much higher maximum link count was observed on Mac OS X than on Ubuntu (\cref{table:nlink}).}
			\item{Correlations between time modified and time created and between inode number and device number were strong on Mac OS X (\cref{fig:corrplot-mac}) and weak on Ubuntu (\cref{fig:corrplot-ubuntu}).}
			\item{Correlations between user ID and group ID, between inode number and group ID, and between inode number and user ID were strong on Ubuntu (\cref{fig:corrplot-ubuntu}) and weak on Mac OS X (\cref{fig:corrplot-mac}).}
		\end{enumerate}

		Why a much higher maximum file size was observed on Ubuntu is currently unknown. It is possible that this is the result of a statistical outlier, such as one Ubuntu machine being used to store several very large files, that might have lead to a bias in the dataset. It is also possible that Ubuntu stores large files, such as backups or swap files, in the user's home directory, while Mac OS X stores these files in a location that was not visited by the traversal program.

		Similarly, the cause of the significantly higher maximum link count on Ubuntu is also unknown. Once again, this may be a statistical outlier such as the result of some form of filesystem corruption on one of the compters from which data was collected. The mean link count on Mac OS X was only slightly higher than that on Ubuntu, but the standard deviation was much higher, implying that filesystem objects with significantly more links than the average are much more common on Mac OS X. However, the maximum observed link count on OS X is more than 800 standard deviations away from the mean, implying that it is an outlier of some form.

		The difference in correlations are probably a result of differences in the filesystem implementation on both operating systems. Many of the differences in correlations involved inode numbers, which implies that Mac OS X and Ubuntu may assign inode numbers differently or order the inode table differently. Perhaps Mac OS X assigns inode numbers based on which device the inode is on, while Ubuntu assigns them based on the user ID of the owner. Group ID and user IDs were strongly correlated on Ubuntu, but weakly correlated on Mac OS X, implying that perhaps the way these two operating systems handle users and groups may differ as well.

	\begin{appendices}

		\section{Data Sources}
			\label[appendix]{app:data}
			\begin{table}[H]
			\centering
				\begin{tabular}{lcr}\hline%
					\textbf{Name} & \textbf{Platform} & \textbf{Timestamp}\\\hline
					\csvreader[head to column names]{traverse/data/datafiles.csv}{}%
					{\\\Name & \Platform & \Timestamp}%
				     \\\hline
			   \end{tabular}
			   \caption{Data sources for filesystem data.}
			   \label{table:datasources}
			\end{table}

			\Cref{table:datasources} shows a listing of the computers from which data was collected. As seen in the table, data was collected from five computers running Mac OS X, self-reporting as ``darwin'', and from nine computers running Ubuntu, which self-reported as ``linux2''. While some individuals, including the author, contributed data multiple times, this data was collected from different computers, sometimes running different operating systems. When data was collected from the same computer multiple times, only the most recent dataset was used.

			With the exception of the data provided by Cody Kineer and Gabriel Kelly, all of the data from Ubuntu machines was collected from user accounts on the Alden Hall network at Allegheny College. All contributors other than Harry Grillo were Allegheny College students studying Computer Science.

			The timestamps for the first two data sources do not include the hour, minute, second, or milliseconds, and report only the date. This is due to the fact that timestamps were not collected by the traversal tool when these datasets were collected, and the timestamps were added manually post-collection.
		\pagebreak
		\section{Source Code Listings}
			\subsection{\texttt{traverse.py} Source Code}
			\label[appendix]{app:traverse}
				\lstinputlisting[style=appendixPy]{"traverse/src/traverse.py"}

			\subsection{\texttt{traverselite.py} Source Code}
			\label[appendix]{app:traverselite}
				\lstinputlisting[style=appendixPy]{traverse/src/traverselite.py}

	\end{appendices}

	\clearpage
	\addcontentsline{toc}{section}{References}
	\printbibliography
\end{document}