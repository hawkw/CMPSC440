\documentclass[12pt,a4paper]{article}
\usepackage{algorithm,algpseudocode}
\usepackage[titletoc]{appendix}
\usepackage[compatibility=false]{caption}
\usepackage{fullpage, listings, footnote, graphicx, hyperref, multicol, enumitem, latexsym, placeins, color, csvsimple}
\setdescription{leftmargin=\parindent,labelindent=\parindent}
\pdfpxdimen=\dimexpr 1 in/72\relax
\lstdefinestyle{appendixPy}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  xleftmargin=\parindent,
  xrightmargin=\parindent,
  language=Python,
  showstringspaces=false,
  basicstyle=\small,
  numberstyle=\tiny,
  keywordstyle=\bfseries\color,
  commentstyle=\itshape\color,
  numbers = left,
  tabsize=4,
}
\lstdefinestyle{appendixJava}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  xleftmargin=\parindent,
  xrightmargin=\parindent,
  language=Java,
  showstringspaces=false,
  basicstyle=\small,
  numberstyle=\tiny,
  keywordstyle=\bfseries\color,
  commentstyle=\itshape\color,
  numbers = left,
  tabsize=4,
}
\lstdefinestyle{insetJava}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=tb,
  xleftmargin=\parindent,
  xrightmargin=\parindent,
  language=Java,
  showstringspaces=false,
  basicstyle=\small,
  numberstyle=\tiny,
  keywordstyle=\bfseries\color,
  commentstyle=\itshape\color,
  numbers = left,
  tabsize=4,
}
\author{Hawk Weisman\\CMPSC440: Operating Systems}
\title{Lab 3: Using A Multi-Threaded Producer-Consumer Model}
\date{Monday, February 17th, 2014}
\begin{document}
	\maketitle
  	\section{How multi-threaded Java programs use \texttt{synchronized}}

	Java offers the \texttt{synchronized} keyword for ensuring thread-safety in Java programs. While understanding \texttt{synchronized} in its entirity requires an understanding of the Java memory model, it can be summarized relatively simoly. A method may be made synchronized simply by adding the \texttt{synchronized} keyword to the method declaration, as shown in Listing \ref{lst:method}. Doing so which has two effects: First, it ensures that only one thread may access a synchronized method on the same object at any given time. If a thread is executing a synchronized method, all other threads that attempt to execute the same method on that object block until the first thread's execution is complete. Secondly, it also ensures that synchronized method exits take place before any subsequent invocation of any synchronized method on that object, ensuring that any modifications to the object's state are visible across threads. Together, these effects ensure that two threads may not modify the object's state at the same time.

		\begin{lstlisting}[style=insetJava, caption=Example of synchronized method declarations., label=lst:method]
private int value;

public synchronized void setValue(int value){
	this.value = value;
}

public synchronized void getValue(){
	return value;
}
		\end{lstlisting}

	Within the Java memory model, synchronization functions using an entity called a \textit{monitor lock}, or \textit{monitor}. Every object has such a lock associated with it, and a thread which desires access to that object's fields must \textit{acquire} the monitor lock for that object and then \textit{release} when it is finished. Only the thread which currently owns the lock may change the object's state -- all others are blocked. When the thread releases the lock, the JVM ensures that all changes to the object's state take place before any other threads attempt to acquire the lock. When a thread executes a \texttt{synchronized} method, it automatically acquire the lock on the object which contains that method and then releases it when the method returns. Access to static fields of a class is controlled by a separate lock than that which controls any individual instance of that class.

	In addition to methods, statements may also be made \texttt{synchronized}. Java statements may be synchronized by wrapping them in a \texttt{synchronized} block, as shown in Listing \ref{lst:statement}. When a block is declared as synchronized, the \texttt{synchronized} statement must specify which object provides the monitor lock. 

		\begin{lstlisting}[style=insetJava, caption=Example of synchronized statements., label=lst:statement]
private List valueList;
private int valueCount;

// method declaration is not synchronized
public void addValue(value){
	synchronized(this){
		// code in ths block is synchronized
		valueCount++;
	}
	// code outside of synchronized block is not synchronized
	valueList.add(value);
}
		\end{lstlisting}

		Using synchronized statements rather than methods allows programmers a finer level of control over concurrancy in their programs - for example, as shown in Listing \ref{lst:multilock}, if a class contains three fields that must be synchronized, each one can be given a separate lock in order to reduce unnecessary blocking. That way, if a thread is accessing one field but not the others, only attempts to access that field will be blocked.

		\begin{lstlisting}[style=insetJava, caption=Example of the use of multiple locks to reduce unneeded blocking., label=lst:multilock]
public class MultilockExample{
	// three values which must all be kept synchronized, but may be modified independantly
	private int value1;
	private int value2;
	private int value3;

	// these objects exist to provide separate locks on each value
	private Object lock1 = new Object();
	private Object lock2 = new Object();
	private Object lock3 = new Object();

	// these methods all have locks provided by different objects, and may be interleaved freely
	public void set1(value) {
		synchronized(lock1){
			value1 = value;
		}
	}

	public void set1(value) {
		synchronized(lock3){
			value1 = value;
		}
	}

	public void set1(value) {
		synchronized(lock2){
			value1 = value;
		}
	}
}
		\end{lstlisting}

  \section{The execution behavior of a multi-threaded Java program}

  	In a multi-threaded Java program, a thread may, at any time, be in one of the following states:
  	\begin{description}
  		\item[new]{Also known as ``born''. Threads are created in this state, and they remain in it until the program starts them.}
  		\item[runnable]{After a thread has been started, it becomes runnable. Runnable threads are considered to be executing their tasks.}
  		\item[waiting]{A thread transitions to the waiting state when it is waiting for another thread to perform a task. It will transition back to the runnable state when the thread on which it's waiting signals that it may continue execution.}
  		\item[timed waiting]{Threads may also be instructed to wait for a specific interval of time. They will transition back to the runnable state when the time limit elapses.}
  		\item[terminated]{Threads terminate when they have completed their task.}
  	\end{description}

  	Threads may also be assigned priorities, ranging from \texttt{MIN\_PRIORITY}, or 1, and \allowbreak\texttt{MAX\_PRIORITY}, or 5. Threads without specified priorities are given the default, \allowbrek\texttt{NORM\_PRIORITY}, or 3. Threads with higher priority values are allocated processor time before lower-priority threads, but priority is nondeterministic and will not guarantee that threads will execute in a specific order. 

  	Threads may be created either by creating objects that implement the interface \texttt{Runnable}\footnote{The method used by Professor Kapfhammer in \texttt{Consumer.java}}, which defines one method, \texttt{run()}, or by extending the \texttt{Thread} class, which requires overriding the \texttt{run()} method. 

  \section{Analysis of the output of defective multi-threaded Java programs}

  	When the \texttt{get()} method in \texttt{CubbyHole} is not synchronized, threads 1, 2, 3, and 4 all throw \allowbreak\texttt{java.lang.IllegalMonitorStateException} at the call to \texttt{Consumer.run()}. When the \texttt{put()} method is not synchronized, thread 0 throws that exception at the call to \texttt{Producer.run()}. When both methods are not synchronized, all five threads throw that exception.

  	According to the Java Platform 7 SE, \allowbreak\texttt{IllegalMonitorStateException}s are thrown ``to indicate that a thread has attempted to wait on an object's monitor or to notify other threads waiting on an object's monitor without owning the specified monitor.'' In light of this and our understanding of monitor locks as discussed in Section 1, we can piece an understanding of how this defect functions. If the \texttt{get()} and \texttt{put()} methods are not synchronized, then threads which call them do not gain ownership of a monitor lock over the containing object, in this case, the \texttt{CubbyHole}. If \texttt{put()} is not synchronized, then when the \texttt{Producer}, which in this case is thread 0, attempts to \texttt{put} a value in the \texttt{CubbyHole} without a lock on that object, the call to \texttt{notifyAll()} in the \texttt{put()} method, which, according to the Java documentation, will ``wake all threads that are waiting on this object's monitor''. This method throws \allowbreak\texttt{IllegalMonitorStateException} if it is called by a thread which does not currently own the object's monitor lock. Since the thread does not own the monitor, as \texttt{put()} is not synchronized, it throws the exception. Looking at the stack trace for this exception confirms this explanation for the defect --- the exception is indeed thrown by the call to \texttt{notifyAll()}.

  	The defect created when \texttt{get()} is not synchronized is very similar: the exception is thrown when a \texttt{Consumer} attempts to \texttt{wait()} for the \texttt{CubbyHole} becomes available. Once again, the Java documentation states that \texttt{wait()} throws an \allowbreak\texttt{IllegalMonitorStateException} ``if the current thread is not the owner of the object's monitor'', and, since \texttt{get()} is no longer synchronized, threads that call it will not own the monitor lock on the \texttt{CubbyHole}.

  	If calls to \texttt{notifyAll()} and \texttt{wait()}, which throw the exception, are removed, the program runs without throwing exceptions. However, it uses massive amounts of CPU time compared to synchronized execution. The cause of this can be determined by running the defective program in verbose mode and analyzing the output. When the program is not synchronized, every time a number is \texttt{put()} into the \texttt{CubbyHole}, each \texttt{Consumer} \texttt{get())}s it a number of times. This is because a lock is no longer enforced on the contents of the \texttt{CubbyHole}, allowing all the producers to access it simultaneously, and resulting in a significant increase in the number of operations the CPU must perform.

  \section{An experimental study of multi-threaded performance}

  \appendix
  
		\section{Experiment Runner Source Code}

			\lstinputlisting[style=appendixPy]{experiment.py}

		\section{Modified Producer-Consumer Model Source Code}
			
			\subsection{ProducerConsumerModel.java}

				\lstinputlisting[style=appendixJava]{src/ProducerConsumerModel.java}

			\subsection{Parameters.java}

				\lstinputlisting[style=appendixJava]{src/Parameters.java}



\end{document}